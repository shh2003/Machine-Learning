## frames(윈도우)
```
for i in range(0, len(df) - frame_size, hop_size):
        x = df['x'].values[i: i + frame_size]
        y = df['y'].values[i: i + frame_size]
        z = df['z'].values[i: i + frame_size]
    frames.append([x, y, z])
```
i부터 i + frame_size까지 frame_size 길이만큼 데이터를 슬라이싱.
x, y, z는 센서의 3축 값

x : 가로 방향의 가속도 (예: 스마트폰의 좌우 움직임)

y : 세로 방향의 가속도 (앞뒤 움직임)

z : 중력 방향의 가속도 (위아래 움직임)

label: 해당 시점의 동작 (예: 걷기, 뛰기 등)

## 라벨(labels)의 의미
```py
label = stats.mode(df['label'][i: i + frame_size])[0][0]
labels.append(label)
```


하나의 윈도우(80개 시점)에는 여러 라벨이 섞여 있을 수 있음.

가장 많이 등장한 라벨(최빈값)을 해당 윈도우의 대표 라벨로 사용.

labels는 frames와 1:1 대응하여 학습용 정답(y)으로 사용됨.



---

## reshape 하는 이유
모델의 기본 입력은 (batch, timesteps, features)

timesteps: 시간축 길이 (예: 80, 128 등)
features: 센서 축 또는 채널 수 (예: x, y, z → 3)

frames의 shape는 (윈도우 수,3,frame_size)
첫 번째 축: 윈도우 개수
두 번째 축: 센서 축 (x, y, z)
세 번째 축: 시간축

```
#변환 코드
frames = np.asarray(frames).reshape(-1, frame_size, N_FEATURES)

```
---
## 파라미터

| 변수               | 의미                                                | 현재 값                             |
| ---------------- | ------------------------------------------------- | -------------------------------- |
| **`Fs`**         | **샘플링 주파수(Hz)**: 1초에 수집되는 센서 데이터 개수               | 20 → 1초에 20개의 데이터                |
| **`frame_size`** | **한 윈도우가 포함하는 시점 수**:<br>모델이 한 번에 보는 연속된 시간 길이    | `Fs * 4 = 80` → 4초치 데이터          |
| **`hop_size`**   | **윈도우를 이동시키는 간격**:<br>윈도우 시작점을 몇 시점씩 건너뛰며 이동할지 결정 | `Fs * 2 = 40` → 2초 간격으로 새 윈도우 시작 |




| 변경 파라미터        | 결과                                                          |
| -------------- | ----------------------------------------------------------- |
| `Fs` ↑         | 1초당 샘플 수 ↑ → **frame\_size, hop\_size도 자동 증가** → 모델 입력 길이 ↑ |
| `frame_size` ↑ | 모델이 한 번에 보는 시간 ↑ → **장기 패턴 학습**, 하지만 연산 느려짐                 |
| `hop_size` ↓   | 윈도우 간 겹침 ↑ → **데이터 양 증가**, 훈련 시간 ↑                          |
| `hop_size` ↑   | 윈도우 간 겹침 ↓ → **데이터 양 감소**, 훈련 빠름                            |

